import { useState, useCallback } from 'react';
import { Nip46Broker, makeSecret } from '@welshman/signer';
import { loginWithNip46 } from '@welshman/app';
import { useNostrLogin } from '@nostrify/react/login';
import { useToast } from '@/hooks/useToast';
import { useIsMobile } from '@/hooks/useIsMobile';
import { debugLog } from '@/lib/debug';
import { nip19 } from 'nostr-tools';

/**
 * Detect if app is running in PWA mode
 */
function isPWA(): boolean {
  if (typeof window === 'undefined') return false;
  
  return (
    window.matchMedia('(display-mode: standalone)').matches ||
    (window.navigator as any).standalone === true ||
    document.referrer.includes('android-app://') ||
    window.location.search.includes('utm_source=pwa')
  );
}

interface BunkerLoginState {
  isLoading: boolean;
  error: string | null;
  authUrl: string | null;
}

/**
 * Hook for bunker login using Welshman/Coracle pattern
 * This replaces the nostr-tools BunkerSigner with Welshman's Nip46Broker
 * which has built-in polling via waitForNostrconnect()
 */
export function useWelshmanBunkerLogin() {
  const [state, setState] = useState<BunkerLoginState>({
    isLoading: false,
    error: null,
    authUrl: null,
  });

  // Store the broker instance for QR code flow
  const [qrBroker, setQrBroker] = useState<{ broker: Nip46Broker; clientSecret: string; url: string } | null>(null);

  const { toast } = useToast();
  const { addLogin, setLogin } = useNostrLogin();
  const isMobile = useIsMobile();
  const isInPWA = isPWA();

  const bunkerLogin = useCallback(
    async (bunkerUri: string) => {
      setState({ isLoading: true, error: null, authUrl: null });

      try {
        debugLog.bunker('üöÄ Starting Welshman bunker login');
        debugLog.bunker('üìù Bunker URI:', bunkerUri.substring(0, 50) + '...');

        // Default relay for nsec.app
        const relays = ['wss://relay.nsec.app'];

        // Check if this is the QR broker's URL - if so, reuse that broker
        let broker: Nip46Broker;
        let clientSecret: string;

        if (qrBroker && qrBroker.url === bunkerUri) {
          debugLog.bunker('üîÑ Reusing existing QR broker');
          broker = qrBroker.broker;
          clientSecret = qrBroker.clientSecret;
        } else {
          // Generate client secret for this session
          clientSecret = makeSecret();
          debugLog.bunker('üîë Generated client secret');

          // Create Nip46Broker instance
          broker = new Nip46Broker({
            clientSecret,
            relays,
          });

          debugLog.bunker('‚úÖ Created Nip46Broker');
        }

        // Parse the bunker URI to get target pubkey
        let targetPubkey: string;
        let signerRelays: string[] = relays;
        let isAutoGenerated = false; // Track if this is QR code vs manual input

        if (bunkerUri.startsWith('bunker://')) {
          // Extract pubkey from bunker:// URL
          const url = new URL(bunkerUri);
          targetPubkey = url.hostname || url.pathname.replace('//', '');
          
          // Extract relays from URL params if present
          const relayParam = url.searchParams.get('relay');
          if (relayParam) {
            signerRelays = [relayParam];
          }
          
          debugLog.bunker('üìç Parsed bunker:// URL:', { targetPubkey, relays: signerRelays });
        } else if (bunkerUri.includes('@')) {
          // NIP-05 identifier (e.g., user@nsec.app)
          // For now, we'll need to resolve this - simplified approach
          throw new Error('NIP-05 identifiers not yet supported with Welshman broker. Please use bunker:// or nostrconnect:// URL.');
        } else if (bunkerUri.startsWith('nostrconnect://')) {
          // nostrconnect:// URL format: nostrconnect://<client-pubkey>?relay=<relay-url>&target=<signer-pubkey>&...
          const url = new URL(bunkerUri);
          
          // The pubkey in the URL path/hostname is the CLIENT pubkey (us), not the target
          // The target (signer) pubkey comes from the 'target' query parameter
          const targetParam = url.searchParams.get('target');
          
          // Detect if this is auto-generated (for QR code) vs manually pasted
          isAutoGenerated = !targetParam;
          
          // For auto-generated URLs (not yet scanned), target might not be present yet
          // In that case, we'll use the client pubkey from the URL path as a placeholder
          // The actual target will be set after the signer approves and we receive the connect event
          if (targetParam) {
            targetPubkey = targetParam;
            debugLog.bunker('üìç Using target from query param (manually pasted):', targetPubkey);
          } else {
            // Auto-generated URL case - use hostname as temporary target
            // This allows QR generation to work, actual target comes from approval event
            targetPubkey = url.hostname || url.pathname.replace('//', '');
            debugLog.bunker('üìç Auto-generated URL - using client pubkey as placeholder (QR flow):', targetPubkey);
          }
          
          const relayParam = url.searchParams.get('relay');
          if (relayParam) {
            signerRelays = [relayParam];
          }
          
          debugLog.bunker('üìç Parsed nostrconnect:// URL:', { targetPubkey, relays: signerRelays });
        } else {
          throw new Error('Invalid bunker URI format. Expected bunker://, nostrconnect://, or NIP-05 identifier.');
        }

        // Generate the nostrconnect URL for user approval
        // For QR flow with reused broker, we already have the URL
        // For manual input, include the target pubkey
        let connectUrl: string;
        
        if (qrBroker && qrBroker.url === bunkerUri) {
          // Reusing QR broker - the URL is the same as what we're passed
          connectUrl = bunkerUri;
          debugLog.bunker('üîó Reusing QR nostrconnect URL');
        } else {
          // Manual input - generate new URL with target
          connectUrl = await broker.makeNostrconnectUrl({
            ...(isAutoGenerated ? {} : { target: targetPubkey }),
            // Request specific permissions
            perms: 'sign_event:1,sign_event:4,sign_event:6,sign_event:7,sign_event:9734,sign_event:9735,nip04_encrypt,nip04_decrypt,nip44_encrypt,nip44_decrypt',
          });

          debugLog.bunker('üîó Generated nostrconnect URL');
        }

        setState({ isLoading: true, error: null, authUrl: connectUrl });

        // Copy URL to clipboard
        if (navigator.clipboard) {
          try {
            await navigator.clipboard.writeText(connectUrl);
            debugLog.bunker('üìã Copied URL to clipboard');
          } catch (err) {
            debugLog.bunkerWarn('Failed to copy to clipboard:', err);
          }
        }

        // Show appropriate UI based on whether this is auto-generated (QR) or manual input
        if (isAutoGenerated) {
          // QR code flow - don't open a new tab, user will scan the QR
          debugLog.bunker('üì± QR code flow - waiting for user to scan');
          toast({
            title: "üì± Scan QR Code",
            description: "Scan the QR code with your Nostr signer app to connect.",
            duration: 8000,
          });
        } else if (isMobile && isInPWA) {
          // Manual input on mobile PWA
          toast({
            title: "üîó Connection Ready",
            description: "The connection URL has been copied to your clipboard. Please open nsec.app manually to approve.",
            duration: 12000,
          });
        } else {
          // Manual input on desktop - open in new tab
          window.open(connectUrl, '_blank');
          toast({
            title: "‚è≥ Waiting for Approval",
            description: "Please approve the connection in the opened window. This may take a few moments...",
            duration: 8000,
          });
        }

        // Create abort controller for timeout
        const abortController = new AbortController();
        const timeoutId = setTimeout(() => {
          abortController.abort();
        }, 120000); // 2 minute timeout

        try {
          debugLog.bunker('‚è≥ Waiting for nostrconnect approval (polling started)...');
          debugLog.bunker('üì° Polling on relay:', signerRelays[0]);
          debugLog.bunker('üéØ Target (signer) pubkey:', targetPubkey);
          
          // Wait for user to scan QR and approve connection
          // The response will contain the actual user's pubkey
          const response = await broker.waitForNostrconnect(connectUrl, abortController.signal);
          
          clearTimeout(timeoutId);
          
          // Check if we got a valid response
          if (!response) {
            throw new Error('No response received from signer');
          }
          
          debugLog.bunker('‚úÖ Connection approved!', response);

          // Get the actual user pubkey from the response event
          // Note: response.event.pubkey is the signer's (user's) actual pubkey, not the client pubkey
          const pubkey = response?.event?.pubkey;
          
          if (!pubkey) {
            throw new Error('Failed to get public key from response');
          }

          debugLog.bunker('üîë Got user pubkey from response:', pubkey);

          // Store credentials for session restoration
          const credentials = {
            pubkey,
            clientSecret,
            signerPubkey: targetPubkey,
            relays: signerRelays,
          };

          // Save to localStorage for restoration
          const bunkerSessions = JSON.parse(localStorage.getItem('bunkerSessions') || '{}');
          bunkerSessions[pubkey] = credentials;
          localStorage.setItem('bunkerSessions', JSON.stringify(bunkerSessions));
          localStorage.setItem('lastBunkerPubkey', pubkey);

          debugLog.bunker('üíæ Saved bunker session to localStorage');

          // Create the signer and log in using Welshman's loginWithNip46
          // This automatically handles adding to the session
          loginWithNip46(
            pubkey,
            clientSecret,
            targetPubkey,
            signerRelays
          );

          debugLog.bunker('‚úÖ Welshman login successful!');

          // Also add to Nostrify's login system so useCurrentUser detects it
          // Convert clientSecret (hex) to nsec format for Nostrify compatibility
          const clientSecretBytes = new Uint8Array(clientSecret.match(/.{1,2}/g)!.map(byte => parseInt(byte, 16)));
          const clientNsec = nip19.nsecEncode(clientSecretBytes);

          debugLog.bunker('üîê Converted client secret to nsec format');

          // Use standard bunker type that Nostrify understands
          const loginId = `welshman-bunker-${pubkey}`;
          const nostrifyLogin: any = {
            id: loginId,
            type: 'bunker', // Use standard bunker type
            pubkey,
            createdAt: new Date().toISOString(),
            data: {
              bunkerPubkey: targetPubkey,
              clientNsec: clientNsec, // Nostrify expects nsec-encoded client secret
              relays: signerRelays,
            },
          };

          addLogin(nostrifyLogin);
          setLogin(loginId);

          debugLog.bunker('‚úÖ Integrated with Nostrify login system');

          toast({
            title: "‚úÖ Connected",
            description: "Successfully connected to your remote signer!",
          });

          setState({ isLoading: false, error: null, authUrl: null });

        } catch (waitError: any) {
          clearTimeout(timeoutId);
          
          // Check if it's an AbortError (from timeout)
          if (waitError?.name === 'AbortError' || waitError?.constructor?.name === 'AbortError') {
            throw new Error('Connection timeout. Please try again and approve the connection promptly.');
          }
          throw waitError;
        }

      } catch (err: any) {
        debugLog.bunkerError('‚ùå Bunker login failed:', err);
        
        const errorMessage = err?.message || String(err) || 'Failed to connect to remote signer';
        setState({ isLoading: false, error: errorMessage, authUrl: null });

        toast({
          title: "Connection Failed",
          description: errorMessage,
          variant: "destructive",
        });
      }
    },
    [toast, isMobile, isInPWA, qrBroker, addLogin, setLogin]
  );

  /**
   * Generate a nostrconnect:// URL for QR code display
   * This creates a new broker instance that will be reused for polling
   */
  const generateQRUrl = useCallback(async () => {
    try {
      const clientSecret = makeSecret();
      const relays = ['wss://relay.nsec.app'];
      
      const broker = new Nip46Broker({
        clientSecret,
        relays,
      });

      debugLog.bunker('‚úÖ Created broker for QR code generation');

      // Generate URL without target (for QR code, signer provides target on scan)
      // Include url and name so the signer knows what app is requesting access
      const url = await broker.makeNostrconnectUrl({
        url: window.location.origin,
        name: document.title || 'ZapTok',
        perms: 'sign_event:1,sign_event:4,sign_event:6,sign_event:7,sign_event:9734,sign_event:9735,nip04_encrypt,nip04_decrypt,nip44_encrypt,nip44_decrypt',
      });

      debugLog.bunker('üîó Generated QR nostrconnect URL');

      // Store the broker for later use in polling
      setQrBroker({ broker, clientSecret, url });

      return url;
    } catch (err) {
      debugLog.bunkerError('Failed to generate QR URL:', err);
      throw err;
    }
  }, []);

  return {
    bunkerLogin,
    generateQRUrl,
    ...state,
  };
}
